<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>PowderBox</title>
<style>
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body {
    background: #1a1a1a;
    color: #fff;
    font-family: 'Segoe UI', system-ui, sans-serif;
    height: 100dvh;
    display: flex;
    flex-direction: column;
    overflow: hidden;
    user-select: none;
    -webkit-user-select: none;
  }

/* TOP BAR */
#topBar {
background: #2a2a2a;
padding: 8px 12px;
display: flex;
align-items: center;
justify-content: space-between;
border-bottom: 1px solid #444;
flex-shrink: 0;
}
#fpsDisplay {
font-size: 11px;
color: #888;
font-weight: 600;
letter-spacing: 0.5px;
}
#topBar h1 {
font-size: 15px;
font-weight: 700;
color: #fff;
letter-spacing: 1px;
}
#clearBtn {
background: #3a3a3a;
border: 1px solid #555;
color: #fff;
border-radius: 8px;
padding: 5px 14px;
font-size: 12px;
font-weight: 600;
cursor: pointer;
display: flex;
align-items: center;
gap: 6px;
transition: background 0.15s;
}
#clearBtn:hover { background: #4a4a4a; }
#clearBtn svg { width: 13px; height: 13px; }

/* CANVAS */
#simCanvas {
flex: 1;
display: block;
width: 100%;
cursor: crosshair;
touch-action: none;
}

/* STATS OVERLAY */
#statsOverlay {
position: absolute;
bottom: 220px;
left: 14px;
pointer-events: none;
}
#statsOverlay .stat-label {
font-size: 9px;
font-weight: 700;
letter-spacing: 1.5px;
color: rgba(255,255,255,0.4);
margin-bottom: 1px;
}
#statsOverlay .stat-val {
font-size: 13px;
font-weight: 600;
color: rgba(255,255,255,0.7);
margin-bottom: 8px;
}

/* BRUSH SIZE */
#brushIndicator {
position: absolute;
bottom: 220px;
right: 14px;
display: flex;
flex-direction: column;
align-items: center;
gap: 6px;
pointer-events: none;
}
#brushIndicator span {
font-size: 10px;
color: #888;
letter-spacing: 1px;
font-weight: 600;
}

/* SETTINGS BUTTON */
#settingsBtn {
position: absolute;
bottom: 224px;
right: 14px;
width: 44px;
height: 44px;
border-radius: 50%;
background: #fff;
border: none;
cursor: pointer;
display: flex;
align-items: center;
justify-content: center;
box-shadow: 0 2px 12px rgba(0,0,0,0.4);
transition: transform 0.2s;
color: #333;
}
#settingsBtn:hover { transform: rotate(45deg); }
#settingsBtn svg { width: 22px; height: 22px; }

/* BOTTOM PANEL */
#bottomPanel {
background: #2a2a2a;
border-top: 1px solid #444;
flex-shrink: 0;
}
#panelToggle {
display: flex;
align-items: center;
justify-content: center;
gap: 8px;
padding: 8px;
cursor: pointer;
color: #ccc;
font-size: 13px;
font-weight: 600;
letter-spacing: 0.5px;
border-bottom: 1px solid #3a3a3a;
transition: background 0.15s;
background: #252525;
}
#panelToggle:hover { background: #333; }
#panelToggle .arrow { font-size: 12px; transition: transform 0.3s; }
#panelToggle.collapsed .arrow { transform: rotate(180deg); }

#elementPanel {
padding: 10px 10px 14px;
overflow-y: auto;
max-height: 200px;
transition: max-height 0.3s ease;
}
#elementPanel.hidden {
max-height: 0;
overflow: hidden;
padding: 0 10px;
}

/* ELEMENT HEADER */
#elementPanel .panel-header {
display: flex;
align-items: center;
justify-content: space-between;
margin-bottom: 8px;
}
#elementPanel .panel-title {
font-size: 11px;
font-weight: 700;
letter-spacing: 1.5px;
color: #888;
text-transform: uppercase;
}

/* BRUSH SIZE SLIDER */
.brush-row {
display: flex;
align-items: center;
gap: 10px;
margin-bottom: 10px;
}
.brush-row label {
font-size: 11px;
color: #888;
font-weight: 600;
letter-spacing: 1px;
min-width: 36px;
}
#brushSlider {
flex: 1;
-webkit-appearance: none;
height: 4px;
border-radius: 2px;
background: #555;
outline: none;
}
#brushSlider::-webkit-slider-thumb {
-webkit-appearance: none;
width: 16px; height: 16px;
border-radius: 50%;
background: #fff;
cursor: pointer;
}
#brushVal {
font-size: 11px;
color: #ccc;
font-weight: 700;
min-width: 20px;
text-align: right;
}

/* ELEMENT GRID */
#elementGrid {
display: grid;
grid-template-columns: repeat(4, 1fr);
gap: 6px;
}
.elem-btn {
border: none;
border-radius: 8px;
padding: 10px 4px;
font-size: 13px;
font-weight: 700;
cursor: pointer;
text-align: center;
transition: transform 0.1s, box-shadow 0.1s, opacity 0.15s;
letter-spacing: 0.3px;
outline: none;
color: #000;
position: relative;
}
.elem-btn:active { transform: scale(0.93); }
.elem-btn.selected {
box-shadow: 0 0 0 3px #fff, 0 0 0 5px rgba(255,255,255,0.3);
transform: scale(1.04);
z-index: 1;
}
.elem-btn.dark-text { color: rgba(0,0,0,0.75); }
.elem-btn.light-text { color: rgba(255,255,255,0.9); }

/* SETTINGS PANEL */
#settingsPanel {
position: absolute;
bottom: 210px;
right: 14px;
background: #2a2a2a;
border: 1px solid #444;
border-radius: 14px;
padding: 14px;
width: 200px;
display: none;
box-shadow: 0 8px 24px rgba(0,0,0,0.5);
z-index: 10;
}
#settingsPanel.open { display: block; }
#settingsPanel h3 { font-size: 13px; font-weight: 700; color: #ccc; margin-bottom: 12px; letter-spacing: 1px; }
.setting-row { display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px; }
.setting-row label { font-size: 12px; color: #aaa; }
.toggle-btn {
width: 40px; height: 22px; border-radius: 11px;
background: #555; border: none; cursor: pointer;
position: relative; transition: background 0.2s;
}
.toggle-btn.on { background: #4CAF50; }
.toggle-btn::after {
content: ‘’; position: absolute; top: 3px; left: 3px;
width: 16px; height: 16px; border-radius: 50%; background: #fff;
transition: left 0.2s;
}
.toggle-btn.on::after { left: 21px; }
.setting-slider { width: 100%; margin-top: 6px; -webkit-appearance: none; height: 4px; border-radius: 2px; background: #555; outline: none; }
.setting-slider::-webkit-slider-thumb { -webkit-appearance: none; width: 14px; height: 14px; border-radius: 50%; background: #fff; cursor: pointer; }
</style>

</head>
<body>

<!-- TOP BAR -->

<div id="topBar">
  <span id="fpsDisplay">FPS: 60</span>
  <h1>PowderBox</h1>
  <button id="clearBtn" onclick="clearCanvas()">
    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><polyline points="3 6 5 6 21 6"/><path d="M19 6l-1 14H6L5 6"/><path d="M10 11v6M14 11v6"/><path d="M9 6V4h6v2"/></svg>
    Clear
  </button>
</div>

<!-- CANVAS -->

<canvas id="simCanvas"></canvas>

<!-- STATS OVERLAY -->

<div id="statsOverlay">
  <div class="stat-label">TEMPERATURE</div>
  <div class="stat-val" id="tempDisplay">20.0°C</div>
  <div class="stat-label">PRESSURE</div>
  <div class="stat-val" id="pressDisplay">1.0 atm</div>
  <div class="stat-label">PARTICLES</div>
  <div class="stat-val" id="particleDisplay">0</div>
</div>

<!-- SETTINGS BUTTON -->

<button id="settingsBtn" onclick="toggleSettings()">
  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
    <circle cx="12" cy="12" r="3"/>
    <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1-2.83 2.83l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-4 0v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83-2.83l.06-.06A1.65 1.65 0 0 0 4.68 15a1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1 0-4h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 2.83-2.83l.06.06A1.65 1.65 0 0 0 9 4.68a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 4 0v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 2.83l-.06.06A1.65 1.65 0 0 0 19.4 9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 0 4h-.09a1.65 1.65 0 0 0-1.51 1z"/>
  </svg>
</button>

<!-- SETTINGS PANEL -->

<div id="settingsPanel">
  <h3>SETTINGS</h3>
  <div class="setting-row">
    <label>Gravity</label>
    <button class="toggle-btn on" id="gravityToggle" onclick="toggleSetting('gravity',this)"></button>
  </div>
  <div class="setting-row">
    <label>Wind</label>
    <button class="toggle-btn" id="windToggle" onclick="toggleSetting('wind',this)"></button>
  </div>
  <div class="setting-row">
    <label>Heat</label>
    <button class="toggle-btn" id="heatToggle" onclick="toggleSetting('heat',this)"></button>
  </div>
  <div class="setting-row">
    <label>Speed</label>
  </div>
  <input class="setting-slider" type="range" min="1" max="5" value="3" id="speedSlider" oninput="simSpeed=parseInt(this.value)">
</div>

<!-- BOTTOM PANEL -->

<div id="bottomPanel">
  <div id="panelToggle" onclick="togglePanel()">
    <span class="arrow">∧</span>
    <span>Elements</span>
  </div>
  <div id="elementPanel">
    <div class="panel-header">
      <span class="panel-title">Select Element</span>
    </div>
    <div class="brush-row">
      <label>BRUSH</label>
      <input type="range" id="brushSlider" min="1" max="10" value="3" oninput="brushSize=parseInt(this.value);document.getElementById('brushVal').textContent=this.value">
      <span id="brushVal">3</span>
    </div>
    <div id="elementGrid"></div>
  </div>
</div>

<script>
// ─────────────────────────────────────────
// ELEMENTS DEFINITION
// ─────────────────────────────────────────
const ELEMENTS = {
  SAND:   { color: [194,154,76],   density: 1.5, type: 'powder',  gravity: true,  flammable: false, label: 'Sand' },
  WATER:  { color: [70,130,220],   density: 1.0, type: 'liquid',  gravity: true,  flammable: false, label: 'Water' },
  STONE:  { color: [120,120,125],  density: 3.0, type: 'solid',   gravity: false, flammable: false, label: 'Stone' },
  FIRE:   { color: [230,60,10],    density: 0.1, type: 'gas',     gravity: false, flammable: false, label: 'Fire',  hot: true },
  STEAM:  { color: [190,200,210],  density: 0.2, type: 'gas',     gravity: false, flammable: false, label: 'Steam' },
  LAVA:   { color: [210,80,10],    density: 2.0, type: 'liquid',  gravity: true,  flammable: false, label: 'Lava',  hot: true },
  ICE:    { color: [170,210,240],  density: 0.9, type: 'solid',   gravity: false, flammable: false, label: 'Ice' },
  OIL:    { color: [160,145,80],   density: 0.8, type: 'liquid',  gravity: true,  flammable: true,  label: 'Oil' },
  WOOD:   { color: [140,80,30],    density: 2.5, type: 'solid',   gravity: false, flammable: true,  label: 'Wood' },
  SMOKE:  { color: [100,100,110],  density: 0.05,type: 'gas',     gravity: false, flammable: false, label: 'Smoke' },
  ACID:   { color: [50,220,30],    density: 1.1, type: 'liquid',  gravity: true,  flammable: false, label: 'Acid',  corrosive: true },
  SALT:   { color: [230,230,230],  density: 1.4, type: 'powder',  gravity: true,  flammable: false, label: 'Salt' },
  GUNPOWDER: { color: [80,75,80], density: 1.2, type: 'powder',  gravity: true,  flammable: true,  label: 'Powder', explosive: true },
  PLANT:  { color: [30,160,40],    density: 1.0, type: 'solid',   gravity: false, flammable: true,  label: 'Plant' },
  GLASS:  { color: [160,210,230],  density: 2.8, type: 'solid',   gravity: false, flammable: false, label: 'Glass' },
  ERASER: { color: [60,60,60],     density: 0,   type: 'eraser',  gravity: false, flammable: false, label: 'Erase' },
};

const ELEM_COLORS_CSS = {
  SAND: '#c29a4c', WATER: '#4682dc', STONE: '#787880', FIRE: '#e63c0a',
  STEAM: '#bec8d2', LAVA: '#d2500a', ICE: '#aad2f0', OIL: '#a09150',
  WOOD: '#8c501e', SMOKE: '#646468', ACID: '#32dc1e', SALT: '#e6e6e6',
  GUNPOWDER: '#504b50', PLANT: '#1ea028', GLASS: '#a0d2e6', ERASER: '#3c3c3c',
};

const ELEM_TEXT_DARK = new Set(['SAND','WATER','ICE','OIL','SALT','GLASS','STEAM','SMOKE']);

// ─────────────────────────────────────────
// SIMULATION ENGINE
// ─────────────────────────────────────────
const canvas = document.getElementById('simCanvas');
const ctx = canvas.getContext('2d');

const CELL = 4; // pixels per cell
let COLS, ROWS;
let grid, nextGrid;
let imageData, pixels;

let selectedElement = 'SAND';
let brushSize = 3;
let isDrawing = false;
let lastX = -1, lastY = -1;
let simSpeed = 3;
let frameCount = 0;
let lastFpsTime = performance.now();
let settings = { gravity: true, wind: false, heat: false };

// Cell structure: [element_id, temperature, lifetime, moved]
// 0=empty, otherwise ELEM index+1
const ELEM_KEYS = Object.keys(ELEMENTS);
const ELEM_IDX = {};
ELEM_KEYS.forEach((k,i) => ELEM_IDX[k] = i+1);

function initGrid(){
  COLS = Math.floor(canvas.width / CELL);
  ROWS = Math.floor(canvas.height / CELL);
  grid = new Uint16Array(COLS * ROWS * 3); // [type, temp, flags]
  nextGrid = new Uint16Array(COLS * ROWS * 3);
  imageData = ctx.createImageData(canvas.width, canvas.height);
  pixels = imageData.data;
}

function idx(x, y){ return (y * COLS + x) * 3; }
function getType(x, y){ if(x<0||x>=COLS||y<0||y>=ROWS) return -1; return grid[idx(x,y)]; }
function setCell(arr, x, y, type, temp=20, flags=0){
  const i = (y * COLS + x) * 3;
  arr[i] = type; arr[i+1] = Math.min(temp,255); arr[i+2] = flags;
}
function clearCell(arr, x, y){ const i=(y*COLS+x)*3; arr[i]=0;arr[i+1]=20;arr[i+2]=0; }

function resizeCanvas(){
  const rect = canvas.getBoundingClientRect();
  canvas.width = rect.width;
  canvas.height = rect.height;
  initGrid();
}

// ─────────────────────────────────────────
// DRAWING INPUT
// ─────────────────────────────────────────
function getCanvasPos(e){
  const rect = canvas.getBoundingClientRect();
  const clientX = e.touches ? e.touches[0].clientX : e.clientX;
  const clientY = e.touches ? e.touches[0].clientY : e.clientY;
  return {
    x: Math.floor((clientX - rect.left) / CELL),
    y: Math.floor((clientY - rect.top) / CELL)
  };
}

function paintAt(cx, cy){
  const r = brushSize;
  for(let dy = -r; dy <= r; dy++){
    for(let dx = -r; dx <= r; dx++){
      if(dx*dx+dy*dy <= r*r){
        const nx = cx+dx, ny = cy+dy;
        if(nx>=0&&nx<COLS&&ny>=0&&ny<ROWS){
          if(selectedElement === 'ERASER'){
            clearCell(grid, nx, ny);
          } else {
            const type = getType(nx,ny);
            if(type === 0){
              const elemId = ELEM_IDX[selectedElement];
              const temp = selectedElement==='FIRE'||selectedElement==='LAVA' ? 200 : 20;
              setCell(grid, nx, ny, elemId, temp);
            }
          }
        }
      }
    }
  }
}

function drawLine(x0,y0,x1,y1){
  let dx=Math.abs(x1-x0),dy=Math.abs(y1-y0);
  let sx=x0<x1?1:-1,sy=y0<y1?1:-1;
  let err=dx-dy;
  while(true){
    paintAt(x0,y0);
    if(x0===x1&&y0===y1)break;
    let e2=2*err;
    if(e2>-dy){err-=dy;x0+=sx;}
    if(e2<dx){err+=dx;y0+=sy;}
  }
}

canvas.addEventListener('mousedown', e=>{isDrawing=true;const p=getCanvasPos(e);lastX=p.x;lastY=p.y;paintAt(p.x,p.y);});
canvas.addEventListener('mousemove', e=>{if(!isDrawing)return;const p=getCanvasPos(e);drawLine(lastX,lastY,p.x,p.y);lastX=p.x;lastY=p.y;});
canvas.addEventListener('mouseup', ()=>isDrawing=false);
canvas.addEventListener('mouseleave', ()=>isDrawing=false);
canvas.addEventListener('touchstart', e=>{e.preventDefault();isDrawing=true;const p=getCanvasPos(e);lastX=p.x;lastY=p.y;paintAt(p.x,p.y);},{passive:false});
canvas.addEventListener('touchmove', e=>{e.preventDefault();if(!isDrawing)return;const p=getCanvasPos(e);drawLine(lastX,lastY,p.x,p.y);lastX=p.x;lastY=p.y;},{passive:false});
canvas.addEventListener('touchend', ()=>isDrawing=false);

// ─────────────────────────────────────────
// SIMULATION STEP
// ─────────────────────────────────────────
// Shuffle columns for fairness
let shuffled = [];
function buildShuffled(){
  shuffled = Array.from({length:COLS},(_,i)=>i);
  for(let i=shuffled.length-1;i>0;i--){
    const j=Math.floor(Math.random()*(i+1));
    [shuffled[i],shuffled[j]]=[shuffled[j],shuffled[i]];
  }
}

function step(){
  for(let s=0;s<simSpeed;s++) doStep();
}

function doStep(){
  nextGrid.set(grid);
  buildShuffled();

  // Bottom to top for gravity elements
  for(let y=ROWS-1;y>=0;y--){
    const dir = Math.random()<0.5?1:-1;
    for(let xi=0;xi<COLS;xi++){
      const x = shuffled[xi];
      const i = idx(x,y);
      const type = grid[i];
      if(type===0) continue;
      const temp = grid[i+1];
      const flags = grid[i+2];
      if(flags & 1) continue; // already moved this frame

      const key = ELEM_KEYS[type-1];
      const elem = ELEMENTS[key];

      // FIRE behavior
      if(key==='FIRE'){
        const newLife = temp - 2;
        if(newLife <= 0){
          // Turn to smoke sometimes
          if(Math.random()<0.4){
            setCell(nextGrid, x, y, ELEM_IDX['SMOKE'], 20, 1);
          } else {
            clearCell(nextGrid, x, y);
          }
          continue;
        }
        setCell(nextGrid, x, y, type, newLife, 1);
        // Spread fire
        const neighbors = [[x-1,y],[x+1,y],[x,y-1],[x,y+1]];
        for(const [nx,ny] of neighbors){
          if(nx<0||nx>=COLS||ny<0||ny>=ROWS) continue;
          const ntype = getType(nx,ny);
          if(ntype===0) continue;
          const nkey = ELEM_KEYS[ntype-1];
          const nelem = ELEMENTS[nkey];
          if(nelem.flammable && Math.random()<0.05){
            setCell(nextGrid, nx, ny, ELEM_IDX['FIRE'], 180, 0);
          }
          // Melt ice
          if(nkey==='ICE' && Math.random()<0.1){
            setCell(nextGrid, nx, ny, ELEM_IDX['WATER'], 20, 0);
          }
          // Boil water to steam
          if(nkey==='WATER' && Math.random()<0.03){
            setCell(nextGrid, nx, ny, ELEM_IDX['STEAM'], 100, 0);
          }
          // Gunpowder explosion
          if(nkey==='GUNPOWDER' && Math.random()<0.3){
            explode(nx,ny,4);
          }
        }
        // Fire rises sometimes
        if(y>0 && getType(x,y-1)===0 && Math.random()<0.3){
          setCell(nextGrid,x,y-1,ELEM_IDX['FIRE'],newLife-10,1);
          clearCell(nextGrid,x,y);
        }
        continue;
      }

      // SMOKE / STEAM behavior (rise)
      if(key==='SMOKE'||key==='STEAM'){
        const newTemp = temp>0?temp-1:0;
        // Steam condenses back to water
        if(key==='STEAM' && newTemp<=0 && Math.random()<0.02){
          setCell(nextGrid,x,y,ELEM_IDX['WATER'],20,1);
          continue;
        }
        // Rise upward
        if(y>0 && getType(x,y-1)===0){
          setCell(nextGrid,x,y-1,type,newTemp,1);
          clearCell(nextGrid,x,y);
        } else {
          // Try diagonals
          const d = Math.random()<0.5?-1:1;
          if(y>0 && x+d>=0 && x+d<COLS && getType(x+d,y-1)===0){
            setCell(nextGrid,x+d,y-1,type,newTemp,1);
            clearCell(nextGrid,x,y);
          } else {
            setCell(nextGrid,x,y,type,newTemp,1);
          }
        }
        continue;
      }

      // LAVA behavior
      if(key==='LAVA'){
        // Spread fire around
        if(Math.random()<0.04){
          const nx=x+(Math.random()<0.5?-1:1), ny=y-1;
          if(nx>=0&&nx<COLS&&ny>=0&&ny<ROWS&&getType(nx,ny)===0){
            setCell(nextGrid,nx,ny,ELEM_IDX['FIRE'],180,0);
          }
        }
        // Solidify if touching water
        let nearWater=false;
        for(const [nx,ny] of [[x-1,y],[x+1,y],[x,y-1],[x,y+1]]){
          if(nx>=0&&nx<COLS&&ny>=0&&ny<ROWS&&ELEM_KEYS[getType(nx,ny)-1]==='WATER'){
            nearWater=true;break;
          }
        }
        if(nearWater && Math.random()<0.1){
          setCell(nextGrid,x,y,ELEM_IDX['STONE'],20,1);
          continue;
        }
      }

      // ACID behavior
      if(key==='ACID'){
        const neighbors = [[x-1,y],[x+1,y],[x,y-1],[x,y+1]];
        for(const [nx,ny] of neighbors){
          if(nx<0||nx>=COLS||ny<0||ny>=ROWS) continue;
          const ntype = getType(nx,ny);
          if(ntype===0) continue;
          const nkey = ELEM_KEYS[ntype-1];
          if(nkey!=='ACID' && nkey!=='GLASS' && Math.random()<0.02){
            clearCell(nextGrid,nx,ny);
            if(Math.random()<0.3) clearCell(nextGrid,x,y);
          }
        }
      }

      // PLANT behavior (grow near water)
      if(key==='PLANT'){
        if(Math.random()<0.005){
          const dirs=[[x-1,y],[x+1,y],[x,y-1],[x,y+1]];
          for(const [nx,ny] of dirs){
            if(nx>=0&&nx<COLS&&ny>=0&&ny<ROWS&&getType(nx,ny)===0&&Math.random()<0.3){
              setCell(nextGrid,nx,ny,ELEM_IDX['PLANT'],20,0);
              break;
            }
          }
        }
        // Check near water
        for(const [nx,ny] of [[x-1,y],[x+1,y],[x,y-1],[x,y+1]]){
          if(nx>=0&&nx<COLS&&ny>=0&&ny<ROWS&&ELEM_KEYS[getType(nx,ny)-1]==='WATER'){
            // Absorb water
            if(Math.random()<0.01) clearCell(nextGrid,nx,ny);
          }
        }
        continue;
      }

      // SALT dissolves in water
      if(key==='SALT'){
        let dissolved=false;
        for(const [nx,ny] of [[x-1,y],[x+1,y],[x,y-1],[x,y+1]]){
          if(nx>=0&&nx<COLS&&ny>=0&&ny<ROWS&&ELEM_KEYS[getType(nx,ny)-1]==='WATER'){
            if(Math.random()<0.01){
              clearCell(nextGrid,x,y);
              clearCell(nextGrid,nx,ny);
              dissolved=true;break;
            }
          }
        }
        if(dissolved) continue;
      }

      // ICE melts near fire/lava
      if(key==='ICE'){
        for(const [nx,ny] of [[x-1,y],[x+1,y],[x,y-1],[x,y+1]]){
          if(nx<0||nx>=COLS||ny<0||ny>=ROWS) continue;
          const nkey = ELEM_KEYS[getType(nx,ny)-1];
          if(nkey==='FIRE'||nkey==='LAVA'){
            if(Math.random()<0.05){
              setCell(nextGrid,x,y,ELEM_IDX['WATER'],20,1);
              break;
            }
          }
        }
        continue;
      }

      // STONE is static
      if(key==='STONE'||key==='GLASS'||key==='PLANT') continue;

      // POWDER (sand, gunpowder, salt) - falls down
      if(elem.type==='powder'){
        if(!settings.gravity) continue;
        if(tryMove(x,y,x,y+1,type,temp)) continue;
        const d2 = Math.random()<0.5?-1:1;
        if(tryMove(x,y,x+d2,y+1,type,temp)) continue;
        if(tryMove(x,y,x-d2,y+1,type,temp)) continue;
        setCell(nextGrid,x,y,type,temp,1);
        continue;
      }

      // LIQUID (water, oil, lava, acid)
      if(elem.type==='liquid'){
        if(!settings.gravity){ setCell(nextGrid,x,y,type,temp,1);continue; }
        if(tryMove(x,y,x,y+1,type,temp)) continue;
        const d2=dir;
        if(tryMove(x,y,x+d2,y,type,temp)) continue;
        if(tryMove(x,y,x-d2,y,type,temp)) continue;
        if(tryMove(x,y,x+d2,y+1,type,temp)) continue;
        if(tryMove(x,y,x-d2,y+1,type,temp)) continue;
        setCell(nextGrid,x,y,type,temp,1);
        continue;
      }
    }
  }
  // Wind effect
  if(settings.wind){
    for(let y=0;y<ROWS;y++){
      if(Math.random()<0.01){
        for(let x=0;x<COLS-1;x++){
          const type=grid[idx(x,y)];
          const ntype=grid[idx(x+1,y)];
          if(type!==0&&ntype===0&&ELEMENTS[ELEM_KEYS[type-1]].type==='powder'){
            if(Math.random()<0.3){
              setCell(nextGrid,x+1,y,type,grid[idx(x,y)+1],0);
              clearCell(nextGrid,x,y);
            }
          }
        }
      }
    }
  }
  grid.set(nextGrid);
  // Clear moved flags
  for(let i=2;i<grid.length;i+=3) grid[i]=0;
}

function tryMove(fx,fy,tx,ty,type,temp){
  if(tx<0||tx>=COLS||ty<0||ty>=ROWS) return false;
  const ttype = getType(tx,ty);
  if(ttype===0){
    setCell(nextGrid,tx,ty,type,temp,1);
    clearCell(nextGrid,fx,fy);
    return true;
  }
  // Density displacement for liquids
  const srcElem = ELEMENTS[ELEM_KEYS[type-1]];
  if(ttype>0){
    const dstElem = ELEMENTS[ELEM_KEYS[ttype-1]];
    if(srcElem.density>dstElem.density && dstElem.type==='liquid' && srcElem.type!=='solid'){
      const dtemp = nextGrid[idx(tx,ty)+1];
      setCell(nextGrid,tx,ty,type,temp,1);
      setCell(nextGrid,fx,fy,ttype,dtemp,1);
      return true;
    }
  }
  return false;
}

function explode(cx,cy,r){
  for(let dy=-r;dy<=r;dy++){
    for(let dx=-r;dx<=r;dx++){
      if(dx*dx+dy*dy<=r*r){
        const nx=cx+dx,ny=cy+dy;
        if(nx>=0&&nx<COLS&&ny>=0&&ny<ROWS){
          clearCell(nextGrid,nx,ny);
          if(Math.random()<0.4) setCell(nextGrid,nx,ny,ELEM_IDX['FIRE'],200,0);
        }
      }
    }
  }
}

// ─────────────────────────────────────────
// RENDER
// ─────────────────────────────────────────
function render(){
  const w = canvas.width, h = canvas.height;
  // Background
  for(let i=0;i<pixels.length;i+=4){
    pixels[i]=26;pixels[i+1]=26;pixels[i+2]=26;pixels[i+3]=255;
  }

  for(let y=0;y<ROWS;y++){
    for(let x=0;x<COLS;x++){
      const type = grid[idx(x,y)];
      if(type===0) continue;
      const key = ELEM_KEYS[type-1];
      let [r,g,b] = ELEMENTS[key].color;

      // Variation
      const v = (Math.random()-0.5)*10;
      r=Math.max(0,Math.min(255,r+v));
      g=Math.max(0,Math.min(255,g+v));
      b=Math.max(0,Math.min(255,b+v));

      // Fire color based on temp
      if(key==='FIRE'){
        const t = grid[idx(x,y)+1]/200;
        r=255; g=Math.floor(t*120); b=0;
      }

      // Fill CELL x CELL pixels
      for(let py=0;py<CELL;py++){
        for(let px=0;px<CELL;px++){
          const screenX=x*CELL+px, screenY=y*CELL+py;
          if(screenX>=w||screenY>=h) continue;
          const pi=(screenY*w+screenX)*4;
          pixels[pi]=r;pixels[pi+1]=g;pixels[pi+2]=b;pixels[pi+3]=255;
        }
      }
    }
  }

  ctx.putImageData(imageData,0,0);

  // FPS
  frameCount++;
  const now=performance.now();
  if(now-lastFpsTime>=500){
    const fps=Math.round(frameCount/((now-lastFpsTime)/1000));
    document.getElementById('fpsDisplay').textContent='FPS: '+fps;
    frameCount=0;lastFpsTime=now;
    updateStats();
  }
}

function updateStats(){
  let count=0;
  let totalTemp=0;
  for(let i=0;i<grid.length;i+=3){
    if(grid[i]>0){count++;totalTemp+=grid[i+1];}
  }
  const avgTemp = count>0?(totalTemp/count).toFixed(1):'20.0';
  document.getElementById('tempDisplay').textContent = avgTemp+'°C';
  document.getElementById('pressDisplay').textContent = (1+count/5000).toFixed(2)+' atm';
  document.getElementById('particleDisplay').textContent = count.toLocaleString();
}

// ─────────────────────────────────────────
// ELEMENT BUTTONS
// ─────────────────────────────────────────
function buildElementGrid(){
  const grid = document.getElementById('elementGrid');
  grid.innerHTML = Object.entries(ELEMENTS).map(([key, elem]) => {
    const isDark = ELEM_TEXT_DARK.has(key);
    return `<button class="elem-btn ${isDark?'dark-text':'light-text'} ${key===selectedElement?'selected':''}"
      style="background:${ELEM_COLORS_CSS[key]}"
      onclick="selectElem('${key}')"
      id="ebtn-${key}"
    >${elem.label}</button>`;
  }).join('');
}

function selectElem(key){
  const prev = document.getElementById('ebtn-'+selectedElement);
  if(prev) prev.classList.remove('selected');
  selectedElement = key;
  const cur = document.getElementById('ebtn-'+key);
  if(cur) cur.classList.add('selected');
}

// ─────────────────────────────────────────
// UI CONTROLS
// ─────────────────────────────────────────
let panelOpen = true;
function togglePanel(){
  panelOpen = !panelOpen;
  const panel = document.getElementById('elementPanel');
  const toggle = document.getElementById('panelToggle');
  panel.classList.toggle('hidden', !panelOpen);
  toggle.classList.toggle('collapsed', !panelOpen);
}

function toggleSettings(){
  document.getElementById('settingsPanel').classList.toggle('open');
}

function toggleSetting(key, btn){
  settings[key] = !settings[key];
  btn.classList.toggle('on', settings[key]);
}

function clearCanvas(){
  grid.fill(0);
  // Restore default temps
  for(let i=1;i<grid.length;i+=3) grid[i]=20;
}

// ─────────────────────────────────────────
// MAIN LOOP
// ─────────────────────────────────────────
function loop(){
  step();
  render();
  requestAnimationFrame(loop);
}

// ─────────────────────────────────────────
// INIT
// ─────────────────────────────────────────
window.addEventListener('resize', ()=>{resizeCanvas();});
// Close settings on outside click
document.addEventListener('click', e=>{
  const panel = document.getElementById('settingsPanel');
  if(panel.classList.contains('open')&&!panel.contains(e.target)&&e.target.id!=='settingsBtn'&&!e.target.closest('#settingsBtn')){
    panel.classList.remove('open');
  }
});

resizeCanvas();
buildElementGrid();
loop();
</script>

</body>
</html>
